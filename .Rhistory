for(v in iv){
means<-tapply(d[,dv], d[,v], mean)
variance<-tapply(d[,dv], d[,v], var)
#  p<-ggqqplot(d, dv, facet.by = v)+
#   labs(title = v)
cat("Means", sep = "\n")
print(round(means,2))
cat("Variances",sep = "\n")
print(round(variance,2))
}
d$language<-as.numeric(d$language)
model<-afex::aov_4(highschool ~ city + language+  (1|id),d, factorize = F)
x<- model # the second unknown parameter
# show_text <- grepl("Two",x$method, fixed =F)
x$anova_table
# dv<-strsplit(x$data.name, split = " by ")[[1]][1] # dependent variable
# iv<-strsplit(x$data.name, split = " by ")[[1]][2] # independent variable
y<-aov4_txt(x)
for (v in row.names(y)){
# Add some text
cat(v, ": **", y[v,]$full, "**",  sep="")
cat("  \n")
# Create plots.....
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
}
col<-colnames(model$data$long[,-1])
n<-length(col)
dv<-col[n]
iv<-gsub(":", "+", row.names(y))
for(v in iv){
means<-tapply(d[,dv], d[,v], mean)
variance<-tapply(d[,dv], d[,v], var)
#  p<-ggqqplot(d, dv, facet.by = v)+
#   labs(title = v)
cat("Means", sep = "\n")
print(round(means,2))
cat("Variances",sep = "\n")
print(round(variance,2))
}
?afex::aov_4
model<-afex::aov_ez(id = id, dv = highschool,
data = d, covariate = language, between = city)
model<-afex::aov_ez(id = "id", dv = "highschool",
data = d, covariate = "language", between = "city")
model<-afex::aov_ez(id = "id", dv = "highschool",
data = d, covariate = "language", between = c("city",
"highschool"))
model<-afex::aov_ez(id = "id", dv = "highschool",
data = d, covariate = "language", between = "city",
factorize = F)
model
model$lm
model
model$lm$call$formula
lm_txt<- function(model){
par<-broom::glance(model)
txt<-
broom::tidy(model, conf.int = T, ddl = T) %>%
mutate_if(is.numeric, round, digits=2) %>%
group_by(term) %>%
mutate(p = p_txt(p.value)) %>%
mutate(t = paste("*t*(",par$df.residual,") = ",statistic, sep = "")) %>%
mutate(slope = paste("$B$ = ", estimate, sep = "")) %>%
mutate(slope_ci= paste("95% CI [",conf.low,", ",conf.high,"]", sep = "")) %>%
mutate(slope_full =  paste(slope,", ", slope_ci, sep = "")) %>%
mutate(full= paste(t,", ",p,", ", slope_full, sep = "")) %>%
mutate(small= paste(t,", ",p, sep = ""))
rownames(txt)<- txt$term
list <- setNames(split(txt, seq(nrow(txt))), rownames(txt))
return(list(txt  = list))
}
knitr::opts_chunk$set(echo = F, results = T, message = F, warning = F, comment = "")
source(here::here("R", "function.R"))
library(plyr)
library(broom)
library(dplyr)
library(afex)
library(ggpubr)
library(car)
library(MESS)
data("Ericksen")
d<-Ericksen
d$id<-seq(1:nrow(d))
model<-lm(highschool ~ city + language,d)
x<- model # the second unknown parameter
# show_text <- grepl("Two",x$method, fixed =F)
x
x$anova_table
# dv<-strsplit(x$data.name, split = " by ")[[1]][1] # dependent variable
# iv<-strsplit(x$data.name, split = " by ")[[1]][2] # independent variable
print.summary.table(x)
print.summary.table(summary(x))
print.summary.table(summary(x))
print(summary(x))
library(pander)
pander::pander(x)
y<-lm_txt(x)
y
for (v in row.names(y)){
# Add some text
cat(v, ": **", y[v,]$full, "**",  sep="")
cat("  \n")
# Create plots.....
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
}
v
row.names(y)
row.names(y)
y
lm_txt<- function(model){
par<-broom::glance(model)
txt<-
broom::tidy(model, conf.int = T, ddl = T) %>%
mutate_if(is.numeric, round, digits=2) %>%
group_by(term) %>%
mutate(p = p_txt(p.value)) %>%
mutate(t = paste("*t*(",par$df.residual,") = ",statistic, sep = "")) %>%
mutate(slope = paste("$B$ = ", estimate, sep = "")) %>%
mutate(slope_ci= paste("95% CI [",conf.low,", ",conf.high,"]", sep = "")) %>%
mutate(slope_full =  paste(slope,", ", slope_ci, sep = "")) %>%
mutate(full= paste(t,", ",p,", ", slope_full, sep = "")) %>%
mutate(small= paste(t,", ",p, sep = ""))
rownames(txt)<- txt$Parameter
# list <- setNames(split(txt, seq(nrow(txt))), rownames(txt))
# txt<-txt[txt$Parameter == effect,]
return(txt)
}
y<-lm_txt(x)
for (v in row.names(y)){
# Add some text
cat(v, ": **", y[v,]$full, "**",  sep="")
cat("  \n")
# Create plots.....
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
}
row.names(y)
lm_txt<- function(model){
par<-broom::glance(model)
txt<-
broom::tidy(model, conf.int = T, ddl = T) %>%
mutate_if(is.numeric, round, digits=2) %>%
group_by(term) %>%
mutate(p = p_txt(p.value)) %>%
mutate(t = paste("*t*(",par$df.residual,") = ",statistic, sep = "")) %>%
mutate(slope = paste("$B$ = ", estimate, sep = "")) %>%
mutate(slope_ci= paste("95% CI [",conf.low,", ",conf.high,"]", sep = "")) %>%
mutate(slope_full =  paste(slope,", ", slope_ci, sep = "")) %>%
mutate(full= paste(t,", ",p,", ", slope_full, sep = "")) %>%
mutate(small= paste(t,", ",p, sep = ""))
rownames(txt)<- txt$term
# list <- setNames(split(txt, seq(nrow(txt))), rownames(txt))
# txt<-txt[txt$Parameter == effect,]
return(txt)
}
y<-lm_txt(x)
for (v in row.names(y)){
# Add some text
cat(v, ": **", y[v,]$full, "**",  sep="")
cat("  \n")
# Create plots.....
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
}
# https://stats.stackexchange.com/questions/19227/possible-extensions-to-the-default-diagnostic-plots-for-lm-in-r-and-in-general
residualPlots(model$lm)
# https://stats.stackexchange.com/questions/19227/possible-extensions-to-the-default-diagnostic-plots-for-lm-in-r-and-in-general
residualPlots(model$lm)
qqPlot(model$lm)
spreadLevelPlot(model$lm)
influenceIndexPlot(model$lm)
influencePlot(model$lm)
# avPlots(model$lm)
# https://stats.stackexchange.com/questions/19227/possible-extensions-to-the-default-diagnostic-plots-for-lm-in-r-and-in-general
residualPlots(model)
qqPlot(model)
spreadLevelPlot(model)
influenceIndexPlot(model)
influencePlot(model)
# avPlots(model$lm)
# wallyplot(model$lm)
qqnorm.wally <- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
wallyplot(model$lm, FUN=qqnorm.wally)
# wallyplot(model$lm)
qqnorm.wally <- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
wallyplot(model, FUN=qqnorm.wally)
wallyplot(model, FUN = residualplot)
# wallyplot(model$lm)
qqnorm.wally <- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
wallyplot(model, FUN=qqnorm.wally)
par(ask=F)
wallyplot(model, FUN = residualplot)
par(ask=F)
wallyplot(model, FUN=qqnorm.wally, ask = F)
par(ask=F)
wallyplot(model, FUN=qqnorm.wally)
par(ask=F)
wallyplot(model, FUN=qqnorm.wally)
par(ask=T)
wallyplot(model, FUN=qqnorm.wally)
# wallyplot(model$lm)
qqnorm.wally <- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
par(ask=F)
wallyplot(model, FUN=qqnorm.wally)
wallyplot(model, FUN = residualplot)
par(ask=F)
wallyplot(model, FUN=qqnorm.wally)
wallyplot(model, FUN = residualplot)
par(ask=T)
# wallyplot(model$lm)
qqnorm.wally <- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
par(ask=F)
wallyplot(model, FUN=qqnorm.wally)
wallyplot(model, FUN = residualplot)
par(ask=T)
knitr::opts_chunk$set(echo = F, results = T, message = F, warning = F, comment = "")
source(here::here("R", "function.R"))
library(plyr)
library(dplyr)
library(afex)
library(ggpubr)
library(car)
library(MESS)
data("Ericksen")
d<-Ericksen
d$id<-seq(1:nrow(d))
d$language<-as.numeric(d$language)
model<-t.test(highschool ~ city, d)
# model<-afex::aov_ez(id = "id", dv = "highschool",
#                     data = d, covariate = "language", between = "city",
#                     factorize = F)
x<- model # the second unknown parameter
# show_text <- grepl("Two",x$method, fixed =F)
x
print(x)
tt_txt <- function(model, beta = T, unit = ""){
ttest<-model
# one sample t test
q<-round(ttest$statistic,2)# statistic q
dof<-round(ttest$parameter,2)# global degree of freedom
pv<-p_txt(ttest$p.value)# raw p value. Beyond 10^-6, the round will give 0.
b <- round(ttest$estimate[1] - ifelse(is.na(ttest$estimate[2]),0,ttest$estimate[2]),2)
# estimation of the beta slope.
full<- paste(
ifelse(isTRUE(beta),
paste("*M* = ",b,unit, ", ", sep = ""), ""),
"95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"], *t*(",dof,") = ",q,", ",pv,
sep ="")
small<- paste("*t*(",dof,") = ",q,", ",pv,
sep ="")
M<- paste("*M* = ",b,unit, sep ="")
CI<- paste("95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
CI_raw <- paste("[",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
M_CI <-paste(M, CI, sep= "")
return(list(full=full, small=small, M = M, CI = CI, M_CI = M_CI,
M_raw = b, CI_raw = CI_raw, p = pv))
}
y<-tt_txt(x)
for (v in row.names(y)){
# Add some text
cat(v, ": **", y[v,]$full, "**",  sep="")
cat("  \n")
# Create plots.....
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
}
y
y$full
model$parameter
model$data.name
tt_txt <- function(model, beta = T, unit = ""){
ttest<-model
# one sample t test
q<-round(ttest$statistic,2)# statistic q
dof<-round(ttest$parameter,2)# global degree of freedom
pv<-p_txt(ttest$p.value)# raw p value. Beyond 10^-6, the round will give 0.
b <- round(ttest$estimate[1] - ifelse(is.na(ttest$estimate[2]),0,ttest$estimate[2]),2)
# estimation of the beta slope.
full<- paste(
ifelse(isTRUE(beta),
paste("*M* = ",b,unit, ", ", sep = ""), ""),
"95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"], *t*(",dof,") = ",q,", ",pv,
sep ="")
small<- paste("*t*(",dof,") = ",q,", ",pv,
sep ="")
M<- paste("*M* = ",b,unit, sep ="")
CI<- paste("95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
CI_raw <- paste("[",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
M_CI <-paste(M, CI, sep= "")
return(list(call = model$data.name, full=full, small=small, M = M, CI = CI, M_CI = M_CI,
M_raw = b, CI_raw = CI_raw, p = pv))
}
y<-tt_txt(x)
y$call
y<-tt_txt(x)
cat(y$call, ": **", y$full, "**",  sep="")
cat("  \n")
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
tt_txt <- function(model, beta = T, unit = ""){
ttest<-model
# one sample t test
q<-round(ttest$statistic,2)# statistic q
dof<-round(ttest$parameter,2)# global degree of freedom
pv<-p_txt(ttest$p.value)# raw p value. Beyond 10^-6, the round will give 0.
b <- round(ttest$estimate[1] - ifelse(is.na(ttest$estimate[2]),0,ttest$estimate[2]),2)
# estimation of the beta slope.
full<- paste(
ifelse(isTRUE(beta),
paste("*M* = ",b,unit, ", ", sep = ""), ""),
"95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"], *t*(",dof,") = ",q,", ",pv,
sep ="")
small<- paste("*t*(",dof,") = ",q,", ",pv,
sep ="")
M<- paste("*M_diff* = ",b,unit, sep ="")
CI<- paste("95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
CI_raw <- paste("[",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
M_CI <-paste(M, CI, sep= "")
return(list(call = model$data.name, full=full, small=small, M = M, CI = CI, M_CI = M_CI,
M_raw = b, CI_raw = CI_raw, p = pv))
}
y<-tt_txt(x)
cat(y$call, ": **", y$full, "**",  sep="")
cat("  \n")
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
tt_txt <- function(model, unit = ""){
ttest<-model
q<-round(ttest$statistic,2)# statistic q
dof<-round(ttest$parameter,2)# global degree of freedom
pv<-p_txt(ttest$p.value)# raw p value. Beyond 10^-6, the round will give 0.
b <- round(ttest$estimate[1] - ifelse(is.na(ttest$estimate[2]),0,ttest$estimate[2]),2)
# estimation of the beta slope.
M<- paste("*M_diff* = ",b,unit, sep ="")
CI<- paste("95% CI [",round(ttest$conf.int[1],2),unit,", ",
round(ttest$conf.int[2],2),unit,"],", sep ="")
small<- paste("*t*(",dof,") = ",q,", ",pv,
sep ="")
full<- paste(M,CI, small, sep = ", ")
return(list(call = model$data.name, full=full, small=small, M = M, CI = CI,
p = pv))
}
y<-tt_txt(x)
cat(y$call, ": **", y$full, "**",  sep="")
cat("  \n")
# insert page break
cat("\n")
cat("#####\n")
cat("\n")
d
y$call
dv<-strsplit(y$call, split = " by ")[[1]][1] # dependent variable
iv<-strsplit(y$call, split = " by ")[[1]][2] # independent variable
means<-tapply(d[,dv], d[,v], mean)
dv
iv
d[,dv]
dv<-strsplit(y$call, split = " by ")[[1]][1] # dependent variable
iv<-strsplit(y$call, split = " by ")[[1]][2] # independent variable
means<-tapply(d[,dv], d[,v], mean)
means<-tapply(d[,dv], d[,v], mean)
tapply(d[,dv], d[,v], mean)
means<-tapply(d[,dv], d[,v], mea, na.rm=Tn)
means<-tapply(d[,dv], d[,v], mean, na.rm=T)
d[,dv]
dv<-strsplit(y$call, split = " by ")[[1]][1] # dependent variable
iv<-strsplit(y$call, split = " by ")[[1]][2] # independent variable
means<-tapply(d[,dv], d[,iv], mean)
variance<-tapply(d[,dv], d[,iv], var)
cat("Means", sep = "\n")
print(round(means,2))
cat("Variances",sep = "\n")
print(round(variance,2))
}
dv<-strsplit(y$call, split = " by ")[[1]][1] # dependent variable
iv<-strsplit(y$call, split = " by ")[[1]][2] # independent variable
means<-tapply(d[,dv], d[,iv], mean)
variance<-tapply(d[,dv], d[,iv], var)
cat("Means", sep = "\n")
print(round(means,2))
cat("Variances",sep = "\n")
print(round(variance,2))
dv<-strsplit(y$call, split = " by ")[[1]][1] # dependent variable
iv<-strsplit(y$call, split = " by ")[[1]][2] # independent variable
means<-tapply(d[,dv], d[,iv], mean)
variance<-tapply(d[,dv], d[,iv], var)
cat("Means", sep = "\n")
print(round(means,2))
cat("\n")
cat("Variances",sep = "\n")
print(round(variance,2))
# https://stats.stackexchange.com/questions/19227/possible-extensions-to-the-default-diagnostic-plots-for-lm-in-r-and-in-general
residualPlots(model$lm)
# https://stats.stackexchange.com/questions/19227/possible-extensions-to-the-default-diagnostic-plots-for-lm-in-r-and-in-general
residualPlots(model)
#ANOVA--------------
cool<-
function(data,
model,
output = "html",
open = F,
test = c("lm", "anova"),
filename = test){
rmarkdown::render(paste0(test,".Rmd"), output_format = paste0(output, "_document"),
output_file = filename)
if(open == T){
browseURL(here::here(paste0("anova.", output)))
}
if(open == T & output == "word"){
system2("open","anova.docx")
}
}
data("Ericksen")
d<-Ericksen
d$id<-seq(1:nrow(d))
model<-lm(highschool ~ city + language,d)
#ANOVA--------------
cool<-
function(data,
model,
output = c("html", "word"),
open = F,
test = c("lm", "anova"),
filename = test){
rmarkdown::render(paste0(test,".Rmd"), output_format = paste0(output, "_document"),
output_file = filename)
if(open == T){
browseURL(here::here(paste0("anova.", output)))
}
if(open == T & output == "word"){
system2("open","anova.docx")
}
}
str(model)
model$call
cool(data = d, model = model, output = "word", open = T)
data
data = d
model = model
output = "word"
cool(data = d, model = model, output = "word", open = T, filename = "23")
cool(data = d, model = model, output = "word", open = T, filename = "23",
test = "lm")
#ANOVA--------------
cool<-
function(data,
model,
output = "html",
open = F,
test = "lm",
filename = test){
rmarkdown::render(paste0(test,".Rmd"), output_format = paste0(output, "_document"),
output_file = filename)
if(open == T){
browseURL(here::here(paste0("anova.", output)))
}
if(open == T & output == "word"){
system2("open","anova.docx")
}
}
data("Ericksen")
d<-Ericksen
d$id<-seq(1:nrow(d))
model<-lm(highschool ~ city + language,d)
cool(data = d, model = model, output = "word", open = T, filename = "23",
test = "lm")
knitr::opts_chunk$set(echo = F, results = T, message = F, warning = F, comment = "")
source(here::here("R", "function.R"))
library(plyr)
library(broom)
library(dplyr)
library(pander)
library(afex)
library(ggpubr)
library(car)
library(MESS)
# data("Ericksen")
# d<-Ericksen
# d$id<-seq(1:nrow(d))
# model<-lm(highschool ~ city + language,d)
d<-data
# wallyplot(model$lm)
qqnorm.wally <- function(x, y, ...) { qqnorm(y, ...) ; abline(a=0, b=1) }
wallyplot(model, FUN=qqnorm.wally, hide=FALSE)
wallyplot(model, FUN = residualplot, hide = FALSE)
cool(data = d, model = model, output = "word", open = T, filename = "23",
test = "lm")
